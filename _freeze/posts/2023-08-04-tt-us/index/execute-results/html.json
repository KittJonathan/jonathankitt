{
  "hash": "7b9b78626478f03345c321c42e339bda",
  "result": {
    "markdown": "---\ntitle: \"#TidyTuesday 2023 - Week 31\"\nsubtitle: \"U.S. states\"\nauthor: \"Jonathan Kitt\"\ndate: \"2023-08-04\"\nimage: img/tt_2023_w31_us.png\ntoc: true\ncategories: [R, TidyTuesday, datavis, U.S.]\n---\n\n\n# Introduction\n\n<br>\n\nThe [#TidyTuesday](https://github.com/rfordatascience/tidytuesday) weekly challenge is organised by the R4DS (R for Data Science) Online Learning Community.\n\nEvery tuesday throughout the year, participants work on a common dataset and share the plots they create.\n\nThe [dataset](https://github.com/rfordatascience/tidytuesday/tree/master/data/2023/2023-08-01) for this challenge comes from Wikipedia articles.\n\n<br>\n\n# Getting the data\n\n<br>\n\nFirst of all, let's load the packages we'll be using :\n\n-   [{tidyverse}](https://www.tidyverse.org/) to clean the data and create the plots\n\n-   [{showtext}](https://github.com/yixuan/showtext) to change the fonts used\n\n-   [{rgdal}](https://cloud.r-project.org/web/packages/rgdal/index.html) and [{rgeos}](https://cran.r-project.org/web/packages/rgeos/index.html) to plot the U.S. states as hexagons\n\n-   [{ggtext}](https://wilkelab.org/ggtext/) to add colours in the plot title\n\nIf you don't have these packages installed, simply use the `install.packages()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the packages\nlibrary(tidyverse)\nlibrary(showtext)\nlibrary(rgdal)\nlibrary(rgeos)\nlibrary(ggtext)\n```\n:::\n\n\n<br>\n\nWe also load the fonts we will use in the plots: [**Roboto Condensed**](https://fonts.google.com/specimen/Roboto+Condensed) for the text and [**Bangers**](https://fonts.google.com/specimen/Bangers) for the title.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import the fonts\nfont_add_google(\"Roboto Condensed\", \"Roboto Condensed\")\nfont_add_google(\"Bangers\", \"Bangers\")\nshowtext_auto()\n```\n:::\n\n\n<br>\n\nWe can now download the dataset :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download the dataset\nstates <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-08-01/states.csv')\n```\n:::\n\n\n<br>\n\nWe also download the data to plot U.S. states as hexagons [here](https://team.carto.com/u/andrew/tables/andrew.us_states_hexgrid/public/map). We save the GEO JSON file in a raw/ directory.\n\nWe then load the data:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download the dataset\nus_hex <- readOGR(\"raw/us_states_hexgrid.geojson\")\n```\n:::\n\n\nFor a quick overview of the data, we use the `glimpse()` function from the [{dplyr}](https://dplyr.tidyverse.org/) package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Explore the dataset\nglimpse(states)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 50\nColumns: 14\n$ state               <chr> \"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"Calif…\n$ postal_abbreviation <chr> \"AL\", \"AK\", \"AZ\", \"AR\", \"CA\", \"CO\", \"CT\", \"DE\", \"F…\n$ capital_city        <chr> \"Montgomery\", \"Juneau\", \"Phoenix\", \"Little Rock\", …\n$ largest_city        <chr> \"Huntsville\", \"Anchorage\", \"Phoenix\", \"Little Rock…\n$ admission           <date> 1819-12-14, 1959-01-03, 1912-02-14, 1836-06-15, 1…\n$ population_2020     <dbl> 5024279, 733391, 7151502, 3011524, 39538223, 57737…\n$ total_area_mi2      <dbl> 52420, 665384, 113990, 53179, 163695, 104094, 5543…\n$ total_area_km2      <dbl> 135767, 1723337, 295234, 137732, 423967, 269601, 1…\n$ land_area_mi2       <dbl> 50645, 570641, 113594, 52035, 155779, 103642, 4842…\n$ land_area_km2       <dbl> 131171, 1477953, 294207, 134771, 403466, 268431, 1…\n$ water_area_mi2      <dbl> 1775, 94743, 396, 1143, 7916, 452, 701, 540, 12133…\n$ water_area_km2      <dbl> 4597, 245384, 1026, 2961, 20501, 1170, 1816, 1399,…\n$ n_representatives   <dbl> 7, 1, 9, 4, 52, 8, 5, 1, 28, 14, 2, 2, 17, 9, 4, 4…\n$ demonym             <chr> \"Alabamian\", \"Alaskan\", \"Arizonan\", \"Arkansan\", \"C…\n```\n:::\n:::\n\n\nThe dataset has **50 observations** (rows) and **14 variables** (columns).\n\nEach row represents one **U.S. states**.\n\nWe're going to represent the **ratios between land and water surfaces** for each state.\n\n\n<br>\n\n# Cleaning the data\n\n<br>\n\nWe use the following code to calculate the land/water ratios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Land to water area ratios\nland_to_water_ratios <- states |>\n  # calculate land/total and water/total area ratios\n  mutate(land_area_ratio = round(land_area_km2 / total_area_km2, 3),\n         water_area_ratio = round(1 - land_area_ratio, 3)) |>\n  # select columns\n  select(id = postal_abbreviation, state, land_area_ratio, water_area_ratio)\n\n# View first lines of cleaned data\nhead(land_to_water_ratios)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  id    state      land_area_ratio water_area_ratio\n  <chr> <chr>                <dbl>            <dbl>\n1 AL    Alabama              0.966            0.034\n2 AK    Alaska               0.858            0.142\n3 AZ    Arizona              0.997            0.003\n4 AR    Arkansas             0.979            0.021\n5 CA    California           0.952            0.048\n6 CO    Colorado             0.996            0.004\n```\n:::\n:::\n\n\n<br>\n\nWe calculate the coordinates for boundaries between land and water surfaces for each hexagon:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare data to create hex map of land to water ratio per US state\nus_clean <- us_hex |>\n  # transform hex data into table\n  fortify(region = \"iso3166_2\") |>\n  # transform into tibble format\n  as_tibble() |>\n  # select columns\n  select(id, long, lat) |>\n  # join land to water ratios values\n  left_join(land_to_water_ratios) |>\n  # remove District of Columbia\n  filter(id != \"DC\") |>\n  # add column with point order\n  mutate(pt_nb = rep(1:7, times = 50), .before = long) |>\n  # group by state id\n  group_by(id) |>\n  # calculate parameters for each state\n  mutate(\n    # total area for reactangle around hex\n    area_rect = (long[pt_nb == 3] - long[pt_nb == 5]) * (lat[pt_nb == 1] - lat[pt_nb == 4]),\n    # slope of upper hex triangle\n    slope = (lat[pt_nb == 6] - lat[pt_nb == 1]) / (long[pt_nb == 6] - long[pt_nb == 1]),\n    # y coordinate for horizontal border btwn land/water\n    split_y = ((land_area_ratio * area_rect) / (long[pt_nb == 2] - long[pt_nb == 6]) + lat[pt_nb == 4]),\n    # determine type of split : 1 if split line below upper triangle / 2 if not\n    split_type = case_when(split_y <= lat[pt_nb == 2] ~ 1, TRUE ~ 2),\n    # calculate x coordinates for horizontal border btwn land/water\n    split_x1 = case_when(split_type == 1 ~ min(long),\n                         split_type == 2 ~ long[pt_nb == 6] + ((split_y - lat[pt_nb == 6]) / slope)),\n    split_x2 = case_when(split_type == 1 ~ max(long),\n                         split_type == 2 ~ long[pt_nb == 1] + (long[pt_nb == 1] - split_x1))\n    )\n\n# Subset us_clean data for type 1 split\nus_clean_type1 <- us_clean |>\n  # filter data\n  filter(split_type == 1) |>\n  # create new columns to keep points needed for plot\n  mutate(pt1_x = long[pt_nb == 1], pt1_y = lat[pt_nb == 1],\n         pt2_x = long[pt_nb == 2], pt2_y = lat[pt_nb == 2],\n         pt3_x = unique(split_x2), pt3_y = unique(split_y),\n         pt4_x = unique(split_x1), pt4_y = unique(split_y),\n         pt5_x = long[pt_nb == 6], pt5_y = lat[pt_nb == 6],\n         pt6_x = pt1_x, pt6_y = pt1_y) |>\n  # select columns\n  select(id, pt1_x:pt6_y) |>\n  # ungroup data\n  ungroup() |>\n  # pivot to long format\n  pivot_longer(cols = -id, names_to = \"pt\", values_to = \"value\") |>\n  # separate \"pt\" column\n  separate(col = pt, into = c(\"pt_nb\", \"xy\"), sep = \"_\") |>\n  # remove \"pt\" string from pt_nb column\n  mutate(pt_nb = str_remove_all(pt_nb, \"pt\")) |>\n  # keep distinct rows\n  distinct() |>\n  # pivot to wide format\n  pivot_wider(id_cols = id:pt_nb, names_from = \"xy\", values_from = \"value\")\n\n# Subset us_clean data for type 2 split\nus_clean_type2 <- us_clean |>\n  # filter data\n  filter(split_type == 2) |>\n  # create new columns to keep points needed for plot\n  mutate(pt1_x = long[pt_nb == 1], pt1_y = lat[pt_nb == 1],\n         pt2_x = unique(split_x2), pt2_y = unique(split_y),\n         pt3_x = unique(split_x1), pt3_y = unique(split_y),\n         pt4_x = pt1_x, pt4_y = pt1_y) |>\n  # select columns\n  select(id, pt1_x:pt4_y) |>\n  # ungroup data\n  ungroup() |>\n  # pivot to long format\n  pivot_longer(cols = -id, names_to = \"pt\", values_to = \"value\") |>\n  # separate \"pt\" column\n  separate(col = pt, into = c(\"pt_nb\", \"xy\"), sep = \"_\") |>\n  # remove \"pt\" string from pt_nb column\n  mutate(pt_nb = str_remove_all(pt_nb, \"pt\")) |>\n  # keep distinct rows\n  distinct() |>\n  # pivot to wide format\n  pivot_wider(id_cols = id:pt_nb, names_from = \"xy\", values_from = \"value\")\n```\n:::\n\n\n<br>\n\nWe calculate the coordinates of each hexagon's centre to add text labels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate centres of polygons to plot state labels\ncentres <- gCentroid(us_hex, byid = TRUE) |>\n  as_tibble()\n\nlabels <- us_hex@data$iso3166_2\n\nhex_labels <- tibble(id = labels,\n                     centres) |>\n  filter(id != \"DC\")\n\n# Clean global environment\nrm(centres, labels, land_to_water_ratios, states, us_hex)\n```\n:::\n\n\n<br>\n\n# Creating the plot\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot() +\n  geom_polygon(data = us_clean, aes(x = long, y = lat, group = id),\n               colour = NA, fill = \"#48bf91\") +\n  geom_polygon(data = us_clean_type1, aes(x = x, y = y, group = id),\n               colour = NA, fill = \"#0076be\") +\n  geom_polygon(data = us_clean_type2, aes(x = x, y = y, group = id),\n               colour = NA, fill = \"#0076be\") +\n  geom_polygon(data = us_clean, aes(x = long, y = lat, group = id),\n               colour = \"white\", fill = NA, linewidth = 0.5) +\n  geom_text(data = hex_labels, aes(x = x, y = y, label = id),\n            family = \"Roboto Condensed\", colour = \"black\", size = 16) +\n  coord_map() +\n  labs(title = \"<span style='color:#48bf91;'>Land</span> to <span style='color:#0076be;'>water</span> surface ratios in the U.S.\",\n       caption = \"#TidyTuesday 2023 week 31 | Data from Wikipedia | Jonathan Kitt\") +\n  theme_void() +\n  theme(panel.background = element_rect(fill = \"black\", colour = NA),\n        plot.background = element_rect(fill = \"black\", colour = NA),\n        plot.title = element_markdown(family = \"Bangers\", size = 90,\n                                      hjust = 0.5, colour = \"white\",\n                                      margin = margin(t = 20)),\n        plot.caption = element_text(family = \"Roboto Condensed\", colour = \"white\", size = 30,\n                                    hjust = 0.5, \n                                    margin = margin(b = 5)))\n\nggsave(\"figs/tt_2023_w31_us.png\", p, dpi = 320, width = 12, height = 6)\n```\n:::\n\n\n<br>\n\nAnd here's the result!\n\n![](img/tt_2023_w31_us.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}